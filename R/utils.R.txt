#Connection 
suppressMessages(library(plyr))
suppressMessages(library(dplyr))
suppressMessages(library(reshape))
suppressMessages(library(ggplot2))
#suppressMessages(library(RNeo4j))
#suppressMessages(library(sqldf))
#suppressMessages(library(optparse))

numeric_to_factor <- function(data, breaks) {
  
  #' Converts Numeric to Factor 
  #' 
  #' Divides the range of the input data into intervals and codes the values 
  #' according to which interval they fall.
  #'
  #' @param data the input numeric data
  #' @param breaks either a numeric vector of two or more unique cut points or 
  #' a single number (greater than or equal to 2) giving the number of intervals 
  #' into which to be cut.
  #' @param labels labels for the levels of the resulting categories
  #' 
  #' @return the output factor
  
  # Create the factor
  groups <- cut(data, breaks, include.lowest = TRUE)
  
  # Get the factor's levels
  labels <- levels(groups)
  new_labels <- c()
  
  for (label in labels) {
    
    # Get and append the new label
    first <- strsplit(label, ",")[[1]][1]
    first <- gsub("\\(","",gsub("\\[", "", first))
    first <- format(as.numeric(first), scientific = FALSE)
    new_labels <- c(new_labels, first)
  }
  
  # Update the factor's levels
  levels(groups) <- new_labels
  return(groups)
  
}

getValuesSd <- function(x) {
  return (paste(seq(x), collapse =","))
}  

getBugsInsertions <- function(x, methodName, project){
  
  listCommits <- strsplit(x, ",")[[1]]

  countFun <<- countFun + 1
  if (countFun %% 100 == 0){
    print(paste0("Processing .... ts: ", countFun))
  }
  
  if (length(listCommits) > 1){
    query <- "MATCH  (p:Project )<-[:analyzedProject]-(c:AnalyzedCommit)<-[]-(classe:AnalyzedClass)<-[]-(method:AnalyzedMethod)
    WHERE c.commit IN {paramCommits}
    AND p.name = {paramProject}
    AND method.methodName = {paramMethod}
    WITH c
    OPTIONAL MATCH (bug:AnalyzedBug)<-[:inserts]-(a:CommitInsertion)-[]->(c)
    WHERE bug.bug = \"bug\"
    RETURN c.time as time, c.commit as commitHash, COUNT(DISTINCT ID(bug)) as bugs"
    
    insertions <- cypher(graph, query, paramCommits = c(listCommits), paramProject = project,
                         paramMethod = methodName)
    
  } else {
    query <- "MATCH  (p:Project )<-[:analyzedProject]-(c:AnalyzedCommit)<-[]-(classe:AnalyzedClass)<-[]-(method:AnalyzedMethod)
    WHERE c.commit = {paramCommits}
    AND p.name = {paramProject}
    AND method.methodName = {paramMethod}
    WITH c
    OPTIONAL MATCH (bug:AnalyzedBug)<-[:inserts]-(a:CommitInsertion)-[]->(c)
    WHERE bug.bug = \"bug\"
    RETURN c.time as time, c.commit as commitHash, COUNT(DISTINCT ID(bug)) as bugs"
    
    insertions <- cypher(graph, query, paramCommits = listCommits, paramProject = project,
                         paramMethod = methodName)
  }
  
  if (!is.null(insertions)){
    insertions$time <- as.POSIXct(insertions$time)
    
    insertions <-  as.data.frame(insertions %>%
                                   group_by(time) %>% 
                                   summarise(bugs = sum(bugs)))
    
    insertions <- insertions[order(as.POSIXct(insertions$time)),]
    
    listofBugs <- paste(insertions$bugs, collapse =",")
  } else {
    listofBugs <- rep("0",length(listCommits))
  }
  
  return (listofBugs)
  
}


getTimesProcess <- function(changes, times){
  
  countFun <<- countFun + 1
  if (countFun %% 100 == 0){
    print(paste0("Processing .... ts: ", countFun))
  }
  values <- unique(as.POSIXlt(unlist(strsplit(times, ","))))
  changes <-  as.integer(unlist(strsplit(changes, ",")))
  
  if (length(values) > 1 && length(changes) > 1){
    
    diffSec <- abs(as.integer(difftime(values[1] ,values[length(values)] , units = c("secs"))))
    #Quotient of division
    if (length(values) > 5){
      quarDiv <- diffSec %/% 4
    } else{
      quarDiv <- diffSec %/% length(values)
    }
    
    frames <- c(0)
    for (i in 1:4){
      frames[i]<- tail(frames[1:(i-1)], n=1) + quarDiv
    }
    
    frames <- c(0,frames)
    values<- c(values[1], values)
    quartiles <- c(0,0,0,0,0)
    
    for (k in 1:(length(frames))){
      for (z in 1:(length(values)-1)){
        secs <- abs(as.integer(difftime(values[1] ,values[z+1] , units = c("secs"))))
        if (k <= 4){
          if (secs >= frames[k] && secs < frames[k+1]) {
            quartiles[k] <- quartiles[k] + changes[z]
          }
        } else if (secs >= frames[k]) {
          quartiles[k] <- quartiles[k] + changes[z]
        }
        
      }
    }
  } else {
    quartiles <- c(0,0,0,0,0)
  }
  
  return (c(quartiles))
  
}

getValuesCommits <- function(x){
  return (paste(rep(1,x), collapse =","))
}

#ID's
genId <- function(x) {
  x$id <- seq_len(nrow(x))
  return(x)
}

getTotalChanges <- function (x) {
  Reduce("+",as.integer(strsplit(x, ",")[[1]]))
}

getTotalBugs <- function (x) {
  as.integer(length(as.list(strsplit(x, ","))[[1]]))
}

getTotalBugsIns <- function (x) {
  sum(as.integer(as.list(strsplit(x, ","))[[1]]))
}

ggpareto <- function(x, title) {
  
  #title <- deparse(substitute(x))
  
  x <- data.frame(modality = na.omit(x))
  
  Df <- x %>% group_by(modality) %>% summarise(frequency=n()) %>% 
    arrange(desc(frequency))
  
  Df$modality <- ordered(Df$modality, levels = unlist(Df$modality, use.names = F))
  
  Df <- Df %>% mutate(modality_int = as.integer(modality), 
                      cumfreq = cumsum(frequency), cumperc = cumfreq/nrow(x) * 100)
  
  nr <- nrow(Df)
  N <- sum(Df$frequency)
  
  Df_ticks <- data.frame(xtick0 = rep(nr +.55, 11), xtick1 = rep(nr +.59, 11), 
                         ytick = trunc(seq(0, N, N/10)))
  
  y2 <- c("  0%", " 10%", " 20%", " 30%", " 40%", " 50%", " 60%", " 70%", " 80%", " 90%", "100%")
  
  g <- ggplot(Df, aes(x=modality, y=frequency)) + 
    geom_bar(stat="identity", aes(fill = modality_int)) +
    geom_line(aes(x=modality_int, y = cumfreq, color = modality_int)) +
    geom_point(aes(x=modality_int, y = cumfreq, color = modality_int), pch = 19) +
    scale_y_continuous(breaks=seq(0, trunc(N), trunc(N/10)), limits=c(trunc(-.02 * N), trunc (N * 1.02))) + 
    #scale_y_continuous(trans='log2') + 
    scale_x_discrete(breaks = Df$modality) +
    guides(fill = FALSE, color = FALSE) + 
    annotate("rect", xmin = nr + .55, xmax = nr + 1, 
             ymin = -.02 * N, ymax = N * 1.02, fill = "white") +
    #annotate("text", x = nr + .8, y = seq(0, N/2, N/10), label = y2, size = 3.5) +
    annotate("text", x = nr + .8, y = seq(0, N, N/10), label = y2, size = 3.5) +
    geom_segment(x = nr + .55, xend = nr + .55, y = -.02 * N, yend = N * 1.02, color = "grey50") +
    geom_segment(data = Df_ticks, aes(x = xtick0, y = ytick, xend = xtick1, yend = ytick)) +
    labs(title = paste0("Pareto Chart of ", title), y = "Frequency of Methods With Bugs", x = "Metrics") +
    theme_bw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
  
  print(g)
  
  #return(list(graph = g, Df = Df[, c(3, 1, 2, 4, 5)]))
  return (graph = g)
}

getPrecision <- function(tp, fp) {
  return(tp / (tp + fp))
}

getRecall <- function(tp, fn) {
  return(tp / (tp + fn))
}

getFmeasure <- function(tp, fp, fn) {
  return((2 * tp) / (2 * tp + fp + fn))
}

getStatsProcess <- function(x){
  
  peaks <- tp <- fp <- fn <- tn <- 0
  
  values <- as.integer(unlist(strsplit(listofPeaks[x],",")))
  bugs <- as.integer(unlist(strsplit(listofBugsIns[x],",")))
  
  if (length(values) > 1) {
    for(i in 1:length(values)){
      if (values[i] >= median(values) && bugs[i] > 0) {
        peaks <- peaks + 1
        tp <- tp + 1
      } else if (values[i] >= median(values) && bugs[i] == 0) {
        peaks <- peaks + 1
        fp <- fp + 1
      } else if (values[i] < median(values) && bugs[i] > 0) {
        fn <- fn + 1 
      } else {
        tn <- tn + 1
      }
    }
  }
  
  precision <- getPrecision(tp, fp)
  recall <-  getRecall(tp, fn)
  fmeasure <- getFmeasure(tp, fp, fn)
  
  return(c(peaks, tp, fp, fn, tn, precision, recall, fmeasure))
}



